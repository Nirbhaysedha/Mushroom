apiVersion: apps/v1
kind: Deployment
metadata:
  name: mushroom
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mushroom
  template:
    metadata:
      labels:
        app: mushroom
    spec:
      containers:
      - name: mushroom
        image: mushroom:v1
        resources:
          limits:
            memory: "128Mi"
            cpu: "500m"
        ports:
        - containerPort: 8000

---


apiVersion: v1
kind: Service
metadata:
  name: mushroom
spec:
  selector:
    app: mushroom
  ports:
  - port: 1234
    targetPort: 8000


# # this is second file (service.yaml)

# apiVersion: v1 
# kind: Service 
# metadata:
#   name: mushroom
# spec: 
#   selector:
#     app: mushroom
#   ports:
#   - port: 1234
#   # port no which run outside container ( it is used when we interact with the cluster)
#     targetport: 8000 
#   # portno which runs inside the container
# # this service file is created to ensure the working of pods and interactions of pods











# kubernetes apiVersion: apps/v1 
# # this is first file ( deployment.yaml )
# kind: Deployment
# metadata:
#   name: mushroom
# spec: 
# # spec means how my app gonna function
#   replicas: 2 
#   # 2no of pods in a node   this is tunable such that by tunning this we can scale our service
#   selector:
#     matchLabels:
#       app: mushroom
#   template:
#     metadata:
#       labels:
#         app: mushroom
#     spec:
#       containers:
#       - name: mushroom
#         image: mushroom
#         resources:
#           limits:
#             memory: "128Mi" 
#             # here we have specified 128 megha bytes per pod
#             cpu: "500m" 
#             #1core equals to 1000 mili core here we have written half core 
#         ports:
#         - containerPort: 8080
#          # this port no comes from docker file





# deployment by kubernetes
#deployment.yaml file
# first install kubernets and then in deployment.yaml file wirite 
# kubernets deployment you will get option press that this code is ready
# in yaml file if i add --- this 3 highfen it become seperator such that in one file i can write multiple yaml code

# both deployment.yaml and service.yaml is generated by vscode you just need to type deployment kubernetes for deployment.yaml
# and service kubernetes for service.yaml





# in kubernetes deployment make sure that the terminal is identical 
# that means working on eks , gke , aks or our own terminal is mostly same 
# so i can learn any of them to deploy application in distributed enviornment by kubernetes

# minicube is a tool that enables us to run kubernetes on computer
# kubectl is a command that is used to interact with the cluster


# ----------------------------  steps   ---------------------------------- 
# 1. (make a single yaml file for both deployment and service file)
# 2. conda install docker and open docker desktop in background
# 3. conda install minikube
# 4. minikube start  ( this command create one node in starting and creates kuberntes structures )(and to stop this we have minikube stop)
# 5. kubectl get all -A      ()(-A is for all)
# 6. kubectl get pods -A    (it gives the list and details of the pods)
# 7. kubectl get nodes -A    ( it gives us the list of all the nodes (it includes control plane that is lead node and all other nodes that are slave nodes))
# 8. kubectl delete deployment trip-duration    ( use this command only when you want to delete the deployments otherwise skip this step)
# 9. minicube add node 1   ( this command create new 1 node with specific tech specification which we have provided , skip this if not want to make new node )
# 10. docker build -t trip_duration:v1 . ( this create new docker image)
# 11. minikube image list   (list of images minicube have )
# 12. minikube image load imagename  (by this minicube get the image of our project from docker)
# 13. (prepare kubernetes.yaml file )    (make sure to provide correct details in that file with correct imagename)
# 14. kubectl apply -f kubernetes.yaml    ( to deploy your project , by this pods are created such that your project container will run there) 
# 15. kubectl get deploy                (this command is used to get deployments)
# 16. kubectl delete pod podnamecomplete     ( this command is used to delete the pod but the service will agin generate this that means the only way to delete a pod is editing kuberntes.yaml file  this is the concept of SELF HEALING SYSTEMS)
# 17. minikube dashboard      (this command provide you the url where you can visualize your cluster)  ( here we can see one thing that is replica sets that is created by kubernetes to ensure FEEL SAFE systems such that we have one extra pod even if others get failed)
# 18. minikube service trip-duration      (this commmand provide us access or url)
# 19. kubectl logs -f podnamecomplete    (to get into the pod i am using this command ) (by this we can see the logs of the request we get on this pod , by this we can also notice the concept of load balancing) ( to check the load balancing concept start sending multiple request and you will see at one time another pod get the request)
# 20. kubectl get endpoints ( to get url or access of multiple pods use this command because every pod has different endpoints)
# 21. kubectl get services   ( to get no of services running  this service make us feel safe becuase they perfectly handle pods)
